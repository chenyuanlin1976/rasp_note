# Linux Device Tree (introduced after linux 3.x)

A **devicetree** is a **tree** data structure with **nodes** that describe the devices in a system.

+ Each node has **property/value pairs** that describe the characteristics of the device being represented.
+ Each node has exactly one parent except for the root node, which has no parent.

[deviceTree Spec](https://www.devicetree.org/)

The function of the **device tree** is to describe the **hardware resources** of a platform.

1. This device tree can be passed to the kernel by the bootloader (uboot),
2. The kernel can obtain hardware information from the device tree.

## characteristics

The device tree has 2 characteristics when describing hardware resources.

1. describe hardware resources in a **tree structure**.
   For example, the local bus is the **backbone** of the tree and is called the **root node** in the device tree.
   The IIC bus, SPI bus, and UART bus mounted to the local bus are the **branches** of the tree and are called **child nodes of the root node** in the device tree.
   There is more than one IIC device under the IIC bus, and these branches can be further divided.
2. the device tree can be like a header file (.h file).
   One device tree file refers to another device tree file. This enables code reuse.
   For example, multiple hardware platforms use RK3576 as the main control chip,
   then we can write the hardware resources of the RK3576 chip into a separate device tree file,
   generally using the **.dtsi** suffix. Other device tree files can be referenced directly using **#include xxx.dtsi**.

For example, *arch/arm64/boot/dts/rockchip/rk3576.dtsi*,
this file is generally provided by the chip manufacturer, and contains almost all devices and peripheral interfaces in the rk3576 chip.
When we use it, we only need to write **#include "rk3568.dtsi"** in the device tree source file of our board to import all the devices of the rk3576 chip,
and then we can modify it according to the peripherals on the board.

## Definition of terms

+ **DTB  (Device tree blob)**: Compact binary representation of the device tree.
+ **DTBO (device tree overlay)**: a file compiled and generated by the device tree overlay, which can be added to the DTB.
+ **DTC  (Device tree compiler)**: An open source tool used to create DTB files from DTS files.
+ **DTS  (Device tree source)** refers to a file in **.dts format**, which is a device tree description in **ASII text format**
+ **DTSI** refers to the device tree file provided by the chip manufacturer and **shared** by the same chip platform.

## DTS Syntax format

+ each **node** in the devicetree is named according to the following convention: `node-name@unit-address`
+ The **root node** does not have a node-name or unit-address. It is identified by a forward slash `/`.
+ **Labels** are created by appending a colon `:` to the label name.
+ **References** are created by prefixing the label name with an ampersand `&`.
+ A bytestring is enclosed in square brackets `[]` with each byte represented by two hexadecimal digits. Spaces between each byte are optional. `mac-address = [02 03 04 05 06 07];`  

### Node and property definitions

+ **nodes** are defined with a node-name and unit-address with braces marking the start and end of the node definition. They may be preceded by a label.
  Nodes may contain property definitions and/or child node definitions. If both are present, properties shall come before child nodes.

  ```C
  [label:] node-name@unit-address {
    [properties definitions]
    [child nodes]
  };
  ```

+ Previously defined nodes may be deleted.  
  `/delete-node/ node-name;`  
  `/delete-node/ &label;`  
+ **Property definitions** are name value pairs in the form.
  Property values may be defined as an array of 32-bit integer cells, as null-terminated strings, as bytestrings or a combination of these.  
  `[label:] property-name = value;`  
  `size = <0x4000000>;`  
+ Previously defined properties may be deleted.  
  `/delete-property/ property-name;`
+ Arrays of cells are represented by angle brackets surrounding a space separated list of C-style integers.  
  `interrupts = <17 0xc>;`

## 1st Example of DTS

```C
cpus {
  #address-cells = <1>;
  #size-cells = <0>;
  cpu@0 {
    device_type = "cpu";
    reg = <0>;
    d-cache-block-size = <32>;      // L1- 32 bytes
    i-cache-block-size = <32>;      // L1- 32 bytes
    d-cache-size = <0x8000>;        // L1, 32K
    i-cache-size = <0x8000>;        // L1, 32K
    timebase-frequency = <82500000>;// 82.5 MHz
    clock-frequency = <825000000>;  // 825 MHz
  };
};
```

## 2nd Example of DTS

```C
soc {
  compatible = "simple-bus";
  #address-cells = <1>;             // 1 u32 cell used to encode the address field
  #size-cells = <1>;                // 1 u32 cell used to encode the size    field
  ranges = <0x0 0xe0000000 0x00100000>;
  serial@4600 {                     // serial device
    device_type = "serial";
    compatible = "ns16550";
    reg = <0x4600 0x100>;           // a 256-byte block at offset 0x4600
    clock-frequency = <0>;
    interrupts = <0xA 0x8>;
    interrupt-parent = <&ipic>;
  };
};
```

## Standard Properties

### compatible

`compatible = "fsl,mpc8641", "ns16550";`

### model

`model = "fsl,MPC8349EMITX";`

### phandle

+ Property name: phandle
+ Value type: `<u32>`
+ Description: The phandle property specifies a numerical identifier for a node that is unique within the devicetree.  
  The phandle property value is **used by other nodes** that need to refer to the node associated with the property.

```C
  pic@10000000 {
    phandle = <1>;          // A phandle value of 1 is defined.
    interrupt-controller;
    reg = <0x10000000 0x100>;
  };
```

Another device node could reference the pic node with a phandle value of 1:

```C
  another-device-node {
    interrupt-parent = <1>;
  };
```

### status

### #address-cells and #size-cells

the **#address-cells** and **#size-cells** properties may be used in any device node that has children in the device tree hierarchy  
and describes how child device nodes should be addressed.  

1. The **#address-cells** property defines the number of `<u32>` cells used to encode the **address field** in a child node's **reg property**.
2. The **#size-cells**    property defines the number of `<u32>` cells used to encode the **size field**    in a child node's **reg property**.
3. The #address-cells and #size-cells properties are not inherited from ancestors in the devicetree. They shall be explicitly defined.
4. If missing, a client program should assume a default value of 2 for #address-cells, and a value of 1 for #size-cells.

### reg

+ Property name: reg
+ Property value: `<prop-encoded-array>` encoded as an arbitrary number of (address, length) pairs.
+ Description: The reg property describes the address of the deviceâ€™s resources within the address space defined by its parent bus.  
  Most commonly this means the offsets and lengths of memory-mapped IO register blocks, but may have a different meaning on some bus types.  
  Addresses in the address space defined by the root node are CPU real addresses.  
+ The value is a `<prop-encoded-array>`, composed of an arbitrary number of pairs of address and length, `<address length>`.  
  The number of `<u32>` cells required to specify the address and length are bus-specific and  
  are specified by the **#address-cells** and **#size-cells** properties in the parent of the device node.  
  If the parent node specifies a value of 0 for #size-cells, the length field in the value of reg shall be omitted.
+ The 'reg' property is the 7-bit I2C address.

**Example**: Suppose a device within a system-on-a-chip had 2 blocks of registers,  
The reg property would be encoded as follows (assuming #address-cells and #size-cells values of 1)

```C
  reg = <0x3000 0x20 0xFE00 0x100>;
  // a  32-byte block at offset 0x3000 in the SOC and
  // a 256-byte block at offset 0xFE00.
```

### virtual-reg

### ranges

### dma-ranges

### dma-coherent

### dma-noncoherent

## Interrupts and Interrupt Mapping

## pinctrl-bindings

### Introduction

Hardware modules that control pin multiplexing or configuration parameters such as  
**pull-up/down, tri-state, drive-strength** etc are designated as pin controllers.  
**Each pin controller must be represented as a node in device tree**, just like any other hardware module.  
Hardware modules whose signals are affected by pin configuration are designated client devices.  

For a client device to operate correctly, certain pin controllers must set up certain specific pin configurations.  

+ Some client devices need a single static pin configuration, e.g. set up during initialization.  
+ Others need to reconfigure pins at run-time, for example to tri-state pins when the device is inactive. 

Hence, each client device can define a set of named states.  
The number and names of those states is defined by the client device's own binding.  

The common pinctrl bindings defined in this file provide an infrastructure for client device device tree nodes  
to map those state names to the pin configuration used by those states.

Note that pin controllers themselves may also be client devices of themselves.  
For example, a pin controller may set up its own "active" state when the driver loads.  
This would allow representing a board's static pin configuration in a single place, rather than splitting it across multiple client device nodes.  
The decision to do this or not somewhat rests with the author of individual board device tree files,  
and any requirements imposed by the bindings for the individual client devices in use by that board,  
i.e. whether they require certain specific named states for dynamic pin configuration.

### Pinctrl client devices

For each client device individually, **every pin state is assigned an integer ID**.  
These numbers start at 0, and are contiguous.  
For each state ID, a unique property exists to define the pin configuration.  
Each state may also be assigned a name. When names are used, another property exists to map from those names to the integer IDs.  

Each client device's own binding determines the set of states that must be defined in its device tree node,  
and whether to define the set of state IDs that must be provided, or whether to define the set of state names that must be provided.

#### Required properties

+ **pinctrl-0**: List of phandles, each pointing at a pin configuration node.  
  These referenced pin configuration nodes must be child nodes of the pin controller that they configure.  
  Multiple entries may exist in this list so that multiple pin controllers may be configured,  
  or so that a state may be built from multiple nodes for a single pin controller,  
  each contributing part of the overall configuration.  

  In some cases, it may be useful to define a state, but for it to be empty.  
  This may be required when a common IP block is used in an SoC either without a pin controller,  
  or where the pin controller does not affect the HW module in question.  
  If the binding for that IP block requires certain pin states to exist, they must still be defined, but may be left empty.

+ Optional properties:
  + pinctrl-1: List of phandles, each pointing at a pin configuration node within a pin controller.
  + pinctrl-n: List of phandles, each pointing at a pin configuration node within a pin controller.
  + pinctrl-names: The list of names to assign states. List entry 0 defines the name for integer state ID 0, list entry 1 for state ID 1, and so on.
